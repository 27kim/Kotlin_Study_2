package ch12

/**
 * 프로그래밍 패러다임
 * 1. 절차지향 : 알고리즘과 로직 중심
 * 2. 객체지향 : 클래스 선언이 최우선. 데이터와 데이터를 처리할 메서드를 하나로 묶어 객체를 만들고 객체를 조합해서 프로그래밍 작성
 * 3. 함수형  : 함수 선언이 최우선. 데이터의 흐름이 아니라 함수의 선언과 선언된 함수의 유기적인 흐름이 주목적
 *
 * 주요원칙
 *
 * 1. 일급 객체로서의 함수
 * 2. 순수 함수
 *
 * 함수형 프로그래밍에서 데이터의 특징
 * 1. 데이터는 변경되지 않으며 프로그램의 상태만 표현한다. (데이터 불변성)
 * 2. 함수에서 데이터는 변경하지 않고 새로운 데이터를 만들어 반환한다.
 *
 * - 함수형 프로그래밍에서는 아예 변수가 없다.
 * - 하나의 데이터가 변수에 저장되어 계속 변경되면서 데이터의 변경 흐름에 따로 프로그래밍하는 것이 아니라
 *   --> 변경할 수 없는 상수 데이터만 이용하고 함수의 흐름에 따라 프로그래밍 하자는 개념
 *
 *
 * 1. 일급 객체로서의 함수 p.302
 *   1. 최상위 레벨에 함수를 정의하고 모든 구성요소를 함수 안에 작성한다.
 *   2. 함수를 변수처럼 이요할 수 있다.
 *   3. 변수처럼 다른 함수의 호출 인수로 함수를 사용할 수 있고, 함수를 반환값으로 사용할 수 있다.
 *
 * 2. 순수 함소루 정의되는 함수
 *
 *   "매개 변수와 반환 값을 가지는 함수로, 항상 같은 결과 값이 나와야 하면, 함수 내에서 부수 효과가 발생하지 않아야 한다"
 *
 *    순수함수란?  부수효과가 발생하지 않는다. 항상 같은 값을 반환한다.
 *    부수효과란? 함수 외부의 다른 값을 변경하지 않는다.
 *             별도의 입출력이 발생하지 않는다 (파일, 네트워크, 데이터베이스)
 *    순수함수가 아닌 것들
 *     - 랜덤 값이 발생하는 함수
 *     - 파일 입출력이 발생하는 함수
 *     - 매개변수가 없는 함수 -> 상수
 *     - 반환 값이 없는 함수 -> 의미없는 순수 함수
 * */

/**
 * 변수처럼 이용되는 함수
 *  변수에 데이터를 대입하듯이 함수도 대입할 수 있어야 한다.
 *
 *  코틀린에서 함수를 변수에 대입하려면
 *   1. 람다 함수
 *   2. 함수 참조
 *  를 이용해야 한다.
 *
 * */

val dataVal = 10
//val funVal = fun someFun(){} //이건 안된다.

val funVal1 = {
    x1 : Int ->
    println("값이 할당되는 순간 여기가 실행되는구나?!")
    println("x1 의 값은 $x1")
    x1 * 10
}

var returnData2 = funVal1(10)

fun someFun(){
    println("여기는 someFun")
}

val funVal2 = ::someFun
/**
 * 아래 안됨
 */

//메인 함수 안에 넣지 않으면 에러 발생
//funVal2() //Expection a top level declaration


/**
 * 람다 표현식
 *
 * 람다 표현식이란? 프로그래밍 언어에서 사용되는 개념으로 익명함수를 지칭하는 용어
 *
 * 코틀린에서 함수 형식
 * fun 함수이름 (매개변수) { 함수내용 }
 *
 * 람다 함수 형식
 * { 매개변수 -> 함수 내용 }
 *
 *  1. 람다 함수는 항상 {} 으로 감싸서 표현해야 한다.
 *  2. {} 안에 -> 표시가 있으며 왼쪽은 매개변수, 오른쪽은 함수 내용이다.
 *  3. 매개변수 타입을 선언해야 하며 추론할 수 있을 때는 생략할 수 있다.
 *  4. 함수의 반환값은 함수 내용의 마지막 표현식이다.
 * */

fun sum (x1 : Int, x2 : Int) : Int {
    return x1 + x2
}

//var test2 = { x1 , x2  -> x1 + x2} //타입을 넣지 않아도 에러 발생하네
//{ x1 : Int, x2 : Int -> x1 + x2} //값을 할당하지 않으면 에러 발생하네

//이상해 보이지만? 함수는 일급 객체이므로 함수를 변수에 대입할 수 있고, 다른 함수의 반환 값으로 사용될 수 있다.
//--> 함수는 변수처럼 이용될 수 있다.
var test1 = { x1 : Int, x2 : Int -> x1 + x2}

fun main(args: Array<String>) {

    var lambdaResult = test1(10,20);


    /**
     * ; 로 끊어줘야지 아래에 쓸 수 있음
     * 변수에 담고 호출하지 않고 아래처럼 바로 사용할 수도 있다.
     **/
    { println("이렇게 바로 호출 가능")}()
    run{ println("이렇게도 호출 가능")}

    /**
     * 매개 변수가 없느 람다 함수 정의
     * */

    //람다를 쓸 때는 ;로 끊어줘야 하나?
    ;
    { -> 10 + 20}

    val noParamFun = {10+20}

    val multiLineFun = {
        println("여려 줄을 쓸 수도 있는데 반환 값은 마지막 줄의 결과 값")
        1+1
    }


    /**
     * 멤버 참조 이용
     * */

    class User(val name : String, var age : Int)

    val inputData = User("jane", 4)
    val lambda1 : (User) -> Int = {inputData -> inputData.age}
    println("$lambda1")
    println("${lambda1(inputData)}")
//    val lambda3 : (User) -> Int = {inputData -> inputData::age} // 이건 안되고
//    val lambda2 : (User) -> Int = {User -> User::age} // 이거도 안되고
    val lambda3 : (User) -> Int = User::age // 이건 되네

}

/**
 * 함수 타입 선언
 *
 * 함수 타입이란? 함수의 매개변수와 반환 값을 형식
 * */
val lambdaFun : (Int) -> Int = {x1 -> x1 +10}
//val lambdaFun2= {x1 -> x1 +10} //함수 타입을 빼먹으면 추론할 수 없다고 나온다
val lambdaFun3= {x1 : Int  -> x1 +10} //이럴 때는 람다 안에 매개변수 타입을 넣어줘야 함

/**
 * typealias 를 이용한 타입 정의
 * */

typealias MyType = (Int) -> Boolean

val lambdaFun4 : MyType = {x1 -> x1 > 10}
val lambdaFun5 : MyType = {it > 10}

/**
 * 매개변수 타입 생략
 * */

val lambdaFun6 : (String) -> String = {x1 -> x1 + "테스트"}

/**
 * it 을 이용한 매개변수 이용
 * 변수가 한 개일 때는 별도의 매개변수를 선언하지 않고 함수에서 it으로 매개 변수를 지칭할 수 있음
 *  --> 함수 타입이 정해져 있을 때만 사용 가능함
 * */

val fun6 : (Int) -> Int = {it + 6}
//val fun7  = {it + 6} // 안됨

/**
 * 멤버 참조 이용 --> main 에 예제 있음
 * */